"use strict";
// File: omniscript-core/parser/src/parser.ts
// What: Main OSF parser and serializer - orchestrates parsing and serialization
// Why: Entry point for parsing OSF documents and converting them back to text
// Related: types.ts, lexer/index.ts, block-parsers/index.ts, serializers/index.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
exports.serialize = serialize;
const fs_1 = require("fs");
const path_1 = require("path");
const lexer_1 = require("./lexer");
const block_parsers_1 = require("./block-parsers");
const serializers_1 = require("./serializers");
function parse(input, options = {}) {
    const { resolveIncludes = false, maxDepth = 10 } = options;
    let { basePath } = options;
    // Validate basePath when includes need to be resolved
    if (resolveIncludes) {
        if (!basePath) {
            // Only use process.cwd() when explicitly resolving includes
            if (typeof process !== 'undefined' && process.cwd) {
                basePath = process.cwd();
            }
            else {
                throw new Error('basePath is required when resolveIncludes is true (process.cwd not available)');
            }
        }
    }
    const blocksRaw = (0, lexer_1.findBlocks)(input);
    const blocks = blocksRaw
        .filter(b => b.type !== 'include')
        .map(b => {
        switch (b.type) {
            case 'meta':
                return (0, block_parsers_1.parseMetaBlock)(b.content);
            case 'doc':
                return (0, block_parsers_1.parseDocBlock)(b.content);
            case 'slide':
                return (0, block_parsers_1.parseSlideBlock)(b.content);
            case 'sheet':
                return (0, block_parsers_1.parseSheetBlock)(b.content);
            case 'chart':
                return (0, block_parsers_1.parseChartBlock)(b.content);
            case 'diagram':
                return (0, block_parsers_1.parseDiagramBlock)(b.content);
            case 'code':
                return (0, block_parsers_1.parseCodeBlock)(b.content);
            case 'table':
                return (0, block_parsers_1.parseTableBlock)(b.content);
            default:
                return (0, block_parsers_1.parseDocBlock)(b.content);
        }
    });
    // Find @include directives
    const includes = findIncludes(input);
    const doc = { blocks };
    if (includes.length > 0) {
        doc.includes = includes;
        if (resolveIncludes && basePath) {
            resolveDocumentIncludes(doc, basePath, maxDepth);
        }
    }
    return doc;
}
function findIncludes(input) {
    // Use bounded quantifiers to prevent ReDoS
    const includeRegex = /@include\s{0,20}\{\s{0,20}path:\s{0,20}"([^"]+)"\s{0,20};\s{0,20}\}/g;
    const includes = [];
    let match;
    while ((match = includeRegex.exec(input)) !== null) {
        const path = match[1];
        if (path) {
            includes.push({
                type: 'include',
                path,
            });
        }
    }
    return includes;
}
/**
 * Validate that an include path doesn't escape the base directory
 * Prevents path traversal attacks like ../../../../etc/passwd
 */
function validateIncludePath(basePath, includePath) {
    // Resolve the full path
    const fullPath = (0, path_1.resolve)(basePath, includePath);
    // Normalize both paths to handle .. and . segments
    const normalizedBase = (0, path_1.normalize)(basePath);
    const normalizedFull = (0, path_1.normalize)(fullPath);
    // Get relative path from base to full
    const rel = (0, path_1.relative)(normalizedBase, normalizedFull);
    // Check if path escapes basePath (starts with .. or is absolute)
    if (rel.startsWith('..') || (0, path_1.resolve)(rel) === rel) {
        throw new Error(`Security: Include path "${includePath}" attempts to access files outside base directory`);
    }
    return fullPath;
}
function resolveDocumentIncludes(doc, basePath, maxDepth, currentDepth = 0, resolvedPaths = new Set()) {
    if (currentDepth >= maxDepth) {
        throw new Error(`Include depth exceeded ${maxDepth} (circular reference detected)`);
    }
    if (!doc.includes)
        return;
    for (const include of doc.includes) {
        try {
            // Validate and resolve path (prevents path traversal)
            const fullPath = validateIncludePath(basePath, include.path);
            // Check for circular reference by path
            if (resolvedPaths.has(fullPath)) {
                throw new Error(`Circular reference detected: ${fullPath} is already being resolved`);
            }
            resolvedPaths.add(fullPath);
            const content = (0, fs_1.readFileSync)(fullPath, 'utf-8');
            const included = parse(content, {
                resolveIncludes: false, // Don't auto-resolve, we'll do it manually
                basePath: (0, path_1.dirname)(fullPath),
                maxDepth,
            });
            include.resolved = included;
            // Recursively resolve nested includes
            if (included.includes && included.includes.length > 0) {
                resolveDocumentIncludes(included, (0, path_1.dirname)(fullPath), maxDepth, currentDepth + 1, new Set(resolvedPaths));
            }
            resolvedPaths.delete(fullPath);
        }
        catch (error) {
            const errorMsg = error.message;
            // Don't wrap if already a circular reference error
            if (errorMsg.includes('circular') || errorMsg.includes('depth exceeded')) {
                throw error;
            }
            throw new Error(`Failed to resolve include "${include.path}": ${errorMsg}`);
        }
    }
}
function serialize(doc) {
    return doc.blocks
        .map(b => {
        switch (b.type) {
            case 'meta':
                return (0, serializers_1.serializeMetaBlock)(b);
            case 'doc':
                return (0, serializers_1.serializeDocBlock)(b);
            case 'slide':
                return (0, serializers_1.serializeSlideBlock)(b);
            case 'sheet':
                return (0, serializers_1.serializeSheetBlock)(b);
            case 'chart':
                return (0, serializers_1.serializeChartBlock)(b);
            case 'diagram':
                return (0, serializers_1.serializeDiagramBlock)(b);
            case 'osfcode':
                return (0, serializers_1.serializeCodeBlock)(b);
            case 'table':
                return (0, serializers_1.serializeTableBlock)(b);
            default:
                return (0, serializers_1.serializeDocBlock)(b);
        }
    })
        .join('\n\n');
}
//# sourceMappingURL=parser.js.map