"use strict";
// File: omniscript-core/parser/src/serializers/content.ts
// What: Serialization for content blocks (slides, code, diagrams, etc.)
// Why: Convert complex block types back to OSF syntax
// Related: block-parsers/slide.ts, block-parsers/sheet.ts, block-parsers/chart.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeSlideBlock = serializeSlideBlock;
exports.serializeSheetBlock = serializeSheetBlock;
exports.serializeChartBlock = serializeChartBlock;
exports.serializeDiagramBlock = serializeDiagramBlock;
exports.serializeCodeBlock = serializeCodeBlock;
const text_1 = require("./text");
const strings_1 = require("../lexer/strings");
function serializeSlideBlock(block) {
    const parts = [];
    const { content, ...otherProps } = block;
    Object.entries(otherProps).forEach(([k, v]) => {
        if (k !== 'type' && v !== undefined) {
            parts.push(`  ${k}: ${(0, text_1.serializeValue)(v)};`);
        }
    });
    if (content) {
        if (parts.length > 0)
            parts.push('');
        content.forEach(contentBlock => {
            serializeContentBlock(contentBlock, parts);
        });
    }
    return `@slide {\n${parts.join('\n')}\n}`;
}
function serializeContentBlock(block, parts) {
    switch (block.type) {
        case 'paragraph':
            parts.push(`  ${block.content.map(text_1.serializeTextRun).join('')}`);
            break;
        case 'image':
            parts.push(`  ![${block.alt}](${block.url})`);
            break;
        case 'ordered_list':
            block.items.forEach((item, index) => {
                parts.push(`  ${index + 1}. ${item.content.map(text_1.serializeTextRun).join('')}`);
            });
            break;
        case 'unordered_list':
            block.items.forEach(item => {
                parts.push(`  - ${item.content.map(text_1.serializeTextRun).join('')}`);
            });
            break;
        case 'code':
            parts.push(`  \`\`\`${block.language || ''}`.trim());
            block.content.split('\n').forEach(l => parts.push(`  ${l.trim()}`));
            parts.push('  ```');
            break;
        case 'blockquote':
            block.content.forEach(p => {
                parts.push(`  > ${p.content.map(text_1.serializeTextRun).join('')}`);
            });
            break;
    }
}
function serializeSheetBlock(block) {
    const parts = [];
    const { data, formulas, ...otherProps } = block;
    Object.entries(otherProps).forEach(([k, v]) => {
        if (k !== 'type' && v !== undefined) {
            parts.push(`  ${k}: ${(0, text_1.serializeValue)(v)};`);
        }
    });
    if (data && Object.keys(data).length > 0) {
        parts.push('  data {');
        Object.entries(data).forEach(([key, value]) => {
            parts.push(`    (${key}) = ${(0, text_1.serializeValue)(value)};`);
        });
        parts.push('  }');
    }
    if (formulas && formulas.length > 0) {
        formulas.forEach(formula => {
            const [row, col] = formula.cell;
            parts.push(`  formula (${row},${col}): "${formula.expr}";`);
        });
    }
    return `@sheet {\n${parts.join('\n')}\n}`;
}
function serializeChartBlock(block) {
    const parts = [];
    parts.push(`  type: "${block.chartType}";`);
    parts.push(`  title: "${(0, strings_1.escapeString)(block.title)}";`);
    // Serialize data array in OSF format
    const dataStr = '[' +
        block.data
            .map(series => `{ label: "${(0, strings_1.escapeString)(series.label)}"; values: [${series.values.join(', ')}]; }`)
            .join(', ') +
        ']';
    parts.push(`  data: ${dataStr};`);
    if (block.options) {
        const optsStr = '{ ' +
            Object.entries(block.options)
                .map(([k, v]) => {
                if (typeof v === 'boolean')
                    return `${k}: ${v}`;
                if (Array.isArray(v))
                    return `${k}: [${v.map(x => `"${x}"`).join(', ')}]`;
                return `${k}: "${v}"`;
            })
                .join('; ') +
            '; }';
        parts.push(`  options: ${optsStr};`);
    }
    return `@chart {\n${parts.join('\n')}\n}`;
}
function serializeDiagramBlock(block) {
    const parts = [];
    parts.push(`  type: "${block.diagramType}";`);
    parts.push(`  engine: "${block.engine}";`);
    if (block.title) {
        parts.push(`  title: "${block.title}";`);
    }
    parts.push(`  code: "${(0, strings_1.escapeString)(block.code)}";`);
    return `@diagram {\n${parts.join('\n')}\n}`;
}
function serializeCodeBlock(block) {
    const parts = [];
    parts.push(`  language: "${block.language}";`);
    if (block.caption) {
        parts.push(`  caption: "${block.caption}";`);
    }
    if (block.lineNumbers !== undefined) {
        parts.push(`  lineNumbers: ${block.lineNumbers};`);
    }
    if (block.highlight) {
        parts.push(`  highlight: ${(0, text_1.serializeValue)(block.highlight)};`);
    }
    parts.push(`  code: "${(0, strings_1.escapeString)(block.code)}";`);
    return `@code {\n${parts.join('\n')}\n}`;
}
//# sourceMappingURL=content.js.map